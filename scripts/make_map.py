import os
import xml.etree.ElementTree as ET
from PIL import Image

def generate_headers(xml_file, map_name):
    width = 0
    height = 0
    bg_map = []
    fg0_map = []
    fg1_map = []
    fg2_map = []
    collision_map = []
    def get_map_text(map):
        map_text = "    "
        for y in range(0, height):
            if y > len(map) - 1:
                map_text += "-1, " * width
            else:
                for x in range(0, width):
                    if x > len(map[y]) - 1:
                        map_text += "-1, "
                    else:
                        map_text += f"{map[y][x]}, "
            map_text += "\n    "
        return map_text

    def parse_layer_data(layer_data, layer_width):
        # Split the 1D layer data into 2D based on the layer width
        data = layer_data.strip().split(',')
        rows = [data[i:i + layer_width] for i in range(0, len(data), layer_width)]
        return [list(map(int, row)) for row in rows]

    # Parse the XML file
    tree = ET.parse(xml_file)
    root = tree.getroot()

    # Extract map dimensions
    width = int(root.attrib['width'])
    height = int(root.attrib['height'])

    # Extract layers data
    for layer in root.findall('layer'):
        layer_name = layer.attrib['name']
        layer_data = layer.find('data').text.strip()
        layer_width = int(layer.attrib['width'])
        if layer_name == "ground":
            bg_map = parse_layer_data(layer_data, layer_width)
        elif layer_name == "back_objects":
            fg0_map = parse_layer_data(layer_data, layer_width)
        elif layer_name == "front_objects":
            fg1_map = parse_layer_data(layer_data, layer_width)
        elif layer_name == "front_objects":
            fg2_map = parse_layer_data(layer_data, layer_width)
        elif layer_name == "front_objects":
            collision_map = parse_layer_data(layer_data, layer_width)

    map_c_header_name = map_name
    map_c_header = f"""
    /**
    * @file {map_c_header_name}_map.h
    * DO NOT EDIT THIS FILE. PLEASE SEE THE README ON HOW TO EDIT THE MAP
    * THIS IS A GENERATED FILE
    */
    #ifndef __{map_c_header_name.upper()}_MAP_H
    #define __{map_c_header_name.upper()}_MAP_H

    #include <math.h>
    #include "../utils.h"
    #include "../actors/npc.h"
    #include "map.h"

    npc_t {map_c_header_name}Npc1;

    const int {map_c_header_name}_map_width = {width};
    const int {map_c_header_name}_map_height = {height};
    const int {map_c_header_name}_bg_map[{width * height}] = {{
    {get_map_text(bg_map)}
    }}; // All default to 0 / GRASS
    const int {map_c_header_name}_fg0_map[{width * height}] = {{
    {get_map_text(fg0_map)}
    }}; // All default to 0
    const int {map_c_header_name}_fg1_map[{width * height}] = {{
    {get_map_text(fg1_map)}
    }}; // All default to 0
    const int {map_c_header_name}_fg2_map[{width * height}] = {{
    {get_map_text(fg2_map)}
    }}; // All default to 0
    const int {map_c_header_name}_collision_map[{width * height}] = {{
    {get_map_text(collision_map)}
    }}; // All default to 0
    npc_t *{map_c_header_name}_npcs[32] = {{
        &{map_c_header_name}Npc1,
    }};
    const uint8_t {map_c_header_name}_npcs_length = 1;

    map_t {map_c_header_name}_map = {{
        {map_c_header_name}_map_width,
        {map_c_header_name}_map_height,
        {map_c_header_name}_bg_map,
        {map_c_header_name}_fg0_map,
        {map_c_header_name}_fg1_map,
        {map_c_header_name}_fg2_map,
        {map_c_header_name}_collision_map,
        {map_c_header_name}_npcs,
        {map_c_header_name}_npcs_length,
    }};

    #endif /* __{map_c_header_name.upper()}_MAP_H */
    """

    with open(f"include/maps/{map_c_header_name}_map.h", "w") as f:
        f.write(map_c_header)

# This is used for the map image generation
def create_image_from_xml(xml_file, tileset_file, output_file):
    # Parse XML file
    tree = ET.parse(xml_file)
    root = tree.getroot()

    # Extract map attributes
    map_width = int(root.attrib['width'])
    map_height = int(root.attrib['height'])
    tile_width = int(root.attrib['tilewidth'])
    tile_height = int(root.attrib['tileheight'])

    # Load tileset image
    tileset_image = Image.open(tileset_file)
    tileset_columns = tileset_image.width // tile_width

    # Create an empty image for the final map
    map_image = Image.new('RGBA', (map_width * tile_width, map_height * tile_height))

    # Iterate over each layer in the XML
    for layer in root.findall('layer'):
        layer_name = layer.attrib['name']
        layer_width = int(layer.attrib['width'])
        layer_height = int(layer.attrib['height'])
        layer_data = layer.find('data').text.strip().split(',')

        # Create an image for the current layer
        layer_image = Image.new('RGBA', (layer_width * tile_width, layer_height * tile_height))

        for y in range(layer_height):
            for x in range(layer_width):
                tile_index = int(layer_data[y * layer_width + x])
                if tile_index > 0:
                    tile_index -= 1  # Tileset indices in XML are 1-based
                    tile_x = (tile_index % tileset_columns) * tile_width
                    tile_y = (tile_index // tileset_columns) * tile_height
                    tile = tileset_image.crop((tile_x, tile_y, tile_x + tile_width, tile_y + tile_height))
                    layer_image.paste(tile, (x * tile_width, y * tile_height))

        # Paste the layer image onto the final map image
        map_image.paste(layer_image, (0, 0), layer_image)

    # Save the final map image
    map_image.save(output_file)


# Process all maps in a directory
# This generates the map images and map headers for all TMX files in the directory
def process_all_maps_in_directory(directory, preprocess_directory, tileset_file):
    for filename in os.listdir(directory):
        if filename.endswith('.tmx'):
            xml_file = os.path.join(directory, filename)
            output_file = os.path.splitext(filename)[0] + '.png'
            output_file = os.path.join(preprocess_directory, output_file)
            create_image_from_xml(xml_file, tileset_file, output_file)
            print(f"Generated map image for {filename} and saved to {output_file}")
            generate_headers(xml_file, os.path.splitext(filename)[0])
            print(f"Generated map header for {filename} and saved to include/maps/{os.path.splitext(filename)[0]}_map.h")

# Example usage
tileset_file = 'maps/raw/tileset.png'
directory = 'maps/raw/'
preprocess_directory = 'maps/preprocess/'
process_all_maps_in_directory(directory, preprocess_directory, tileset_file)

# Raw map images are now in maps/preprocess/, and need to be converted to the correct bmp format for butano